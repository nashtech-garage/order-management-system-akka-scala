package com.oms.product.repository

import com.oms.product.model.{Category, Product}
import org.scalatest.BeforeAndAfterAll
import org.scalatest.concurrent.ScalaFutures
import org.scalatest.matchers.should.Matchers
import org.scalatest.time.{Seconds, Span}
import org.scalatest.wordspec.AnyWordSpec
import slick.jdbc.H2Profile.api._
import scala.concurrent.ExecutionContext.Implicits.global

class ProductRepositorySpec extends AnyWordSpec with Matchers with ScalaFutures with BeforeAndAfterAll {

  // Increase timeout for futureValue
  implicit override val patienceConfig = PatienceConfig(timeout = Span(5, Seconds))

  private val db = Database.forURL(
    url = "jdbc:h2:mem:product_test;MODE=PostgreSQL;DB_CLOSE_DELAY=-1;DATABASE_TO_UPPER=false",
    driver = "org.h2.Driver"
  )
  
  private val repository = new ProductRepository(db)

  override def beforeAll(): Unit = {
    super.beforeAll()
    // Create schema
    val setup = DBIO.seq(
      sqlu"""
        CREATE TABLE IF NOT EXISTS categories (
          id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          name VARCHAR(255) NOT NULL,
          description TEXT
        )
      """,
      sqlu"""
        CREATE TABLE IF NOT EXISTS products (
          id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          name VARCHAR(255) NOT NULL,
          description TEXT,
          price DECIMAL(10,2) NOT NULL,
          stock_quantity INT NOT NULL DEFAULT 0,
          category_id BIGINT,
          image_url VARCHAR(500),
          created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
          FOREIGN KEY (category_id) REFERENCES categories(id)
        )
      """
    )
    db.run(setup).futureValue
  }

  override def afterAll(): Unit = {
    db.close()
    super.afterAll()
  }

  "ProductRepository" when {
    "creating a category" should {
      "successfully insert and return category with id" in {
        val category = Category(
          name = "Electronics",
          description = Some("Electronic devices")
        )

        val result = repository.createCategory(category).futureValue

        result.id should not be None
        result.name shouldBe "Electronics"
        result.description shouldBe Some("Electronic devices")
      }
    }

    "finding a category by id" should {
      "return the category when it exists" in {
        val category = Category(name = "Books", description = Some("Book category"))
        val created = repository.createCategory(category).futureValue

        val found = repository.findCategoryById(created.id.get).futureValue

        found should not be None
        found.get.name shouldBe "Books"
        found.get.description shouldBe Some("Book category")
      }

      "return None when category doesn't exist" in {
        val found = repository.findCategoryById(99999L).futureValue
        found shouldBe None
      }
    }

    "finding all categories" should {
      "return all categories" in {
        val categories = repository.findAllCategories().futureValue
        categories.size should be >= 2
      }
    }

    "deleting a category" should {
      "successfully delete the category" in {
        val category = Category(name = "ToDelete", description = None)
        val created = repository.createCategory(category).futureValue

        val deleted = repository.deleteCategory(created.id.get).futureValue
        deleted shouldBe 1

        val found = repository.findCategoryById(created.id.get).futureValue
        found shouldBe None
      }

      "return 0 when category doesn't exist" in {
        val deleted = repository.deleteCategory(99999L).futureValue
        deleted shouldBe 0
      }
    }

    "creating a product" should {
      "successfully insert and return product with id" in {
        val product = Product(
          name = "Test Product",
          description = Some("Test Description"),
          price = BigDecimal("99.99"),
          stockQuantity = 10,
          categoryId = None,
          imageUrl = Some("/uploads/test.jpg")
        )

        val result = repository.createProduct(product).futureValue

        result.id should not be None
        result.name shouldBe "Test Product"
        result.description shouldBe Some("Test Description")
        result.price shouldBe BigDecimal("99.99")
        result.stockQuantity shouldBe 10
        result.imageUrl shouldBe Some("/uploads/test.jpg")
      }

      "successfully insert product with category" in {
        val category = Category(name = "Gadgets", description = None)
        val createdCategory = repository.createCategory(category).futureValue

        val product = Product(
          name = "Gadget Product",
          description = None,
          price = BigDecimal("49.99"),
          stockQuantity = 5,
          categoryId = createdCategory.id,
          imageUrl = None
        )

        val result = repository.createProduct(product).futureValue

        result.id should not be None
        result.categoryId shouldBe createdCategory.id
      }
    }

    "finding a product by id" should {
      "return the product when it exists" in {
        val product = Product(
          name = "Find Me",
          description = Some("Findable product"),
          price = BigDecimal("19.99"),
          stockQuantity = 3
        )
        val created = repository.createProduct(product).futureValue

        val found = repository.findById(created.id.get).futureValue

        found should not be None
        found.get.name shouldBe "Find Me"
        found.get.description shouldBe Some("Findable product")
      }

      "return None when product doesn't exist" in {
        val found = repository.findById(99999L).futureValue
        found shouldBe None
      }
    }

    "finding all products" should {
      "return paginated results" in {
        val products = repository.findAll(0, 10).futureValue
        products should not be empty
      }

      "respect offset and limit" in {
        val firstPage = repository.findAll(0, 2).futureValue
        val secondPage = repository.findAll(2, 2).futureValue

        firstPage should have size 2
        firstPage should not equal secondPage
      }
    }

    "finding products by category" should {
      "return products for specific category" in {
        val category = Category(name = "TestCategory", description = None)
        val createdCategory = repository.createCategory(category).futureValue

        val product1 = Product(
          name = "Product 1",
          description = None,
          price = BigDecimal("10.00"),
          stockQuantity = 1,
          categoryId = createdCategory.id
        )
        val product2 = Product(
          name = "Product 2",
          description = None,
          price = BigDecimal("20.00"),
          stockQuantity = 2,
          categoryId = createdCategory.id
        )

        repository.createProduct(product1).futureValue
        repository.createProduct(product2).futureValue

        val found = repository.findByCategory(createdCategory.id.get, 0, 10).futureValue
        found.size should be >= 2
        found.foreach(_.categoryId shouldBe createdCategory.id)
      }
    }

    "searching products by name" should {
      "return products matching the query" in {
        val product = Product(
          name = "SearchableProduct",
          description = None,
          price = BigDecimal("5.00"),
          stockQuantity = 1
        )
        repository.createProduct(product).futureValue

        val found = repository.searchByName("Searchable", 0, 10).futureValue
        found should not be empty
        found.exists(_.name.contains("Searchable")) shouldBe true
      }

      "be case insensitive" in {
        val product = Product(
          name = "CaseSensitiveProduct",
          description = None,
          price = BigDecimal("5.00"),
          stockQuantity = 1
        )
        repository.createProduct(product).futureValue

        val found = repository.searchByName("casesensitive", 0, 10).futureValue
        found should not be empty
      }
    }

    "updating a product" should {
      "successfully update all fields" in {
        val product = Product(
          name = "Original Name",
          description = Some("Original Description"),
          price = BigDecimal("50.00"),
          stockQuantity = 5
        )
        val created = repository.createProduct(product).futureValue

        val updated = repository.updateProduct(
          id = created.id.get,
          name = Some("Updated Name"),
          description = Some("Updated Description"),
          price = Some(BigDecimal("60.00")),
          stockQuantity = Some(10),
          categoryId = None,
          imageUrl = Some("/uploads/new.jpg")
        ).futureValue

        updated shouldBe 1

        val found = repository.findById(created.id.get).futureValue
        found.get.name shouldBe "Updated Name"
        found.get.description shouldBe Some("Updated Description")
        found.get.price shouldBe BigDecimal("60.00")
        found.get.stockQuantity shouldBe 10
        found.get.imageUrl shouldBe Some("/uploads/new.jpg")
      }

      "successfully update partial fields" in {
        val product = Product(
          name = "Partial Update",
          description = Some("Original"),
          price = BigDecimal("30.00"),
          stockQuantity = 3
        )
        val created = repository.createProduct(product).futureValue

        val updated = repository.updateProduct(
          id = created.id.get,
          name = Some("New Name"),
          description = None,
          price = None,
          stockQuantity = None,
          categoryId = None,
          imageUrl = None
        ).futureValue

        updated shouldBe 1

        val found = repository.findById(created.id.get).futureValue
        found.get.name shouldBe "New Name"
        found.get.description shouldBe Some("Original") // Should keep original
        found.get.price shouldBe BigDecimal("30.00") // Should keep original
      }

      "return 0 when product doesn't exist" in {
        val updated = repository.updateProduct(
          id = 99999L,
          name = Some("New Name"),
          description = None,
          price = None,
          stockQuantity = None,
          categoryId = None,
          imageUrl = None
        ).futureValue

        updated shouldBe 0
      }
    }

    "updating stock" should {
      "successfully update stock quantity" in {
        val product = Product(
          name = "Stock Product",
          description = None,
          price = BigDecimal("10.00"),
          stockQuantity = 5
        )
        val created = repository.createProduct(product).futureValue

        val updated = repository.updateStock(created.id.get, 50).futureValue
        updated shouldBe 1

        val found = repository.findById(created.id.get).futureValue
        found.get.stockQuantity shouldBe 50
      }

      "return 0 when product doesn't exist" in {
        val updated = repository.updateStock(99999L, 50).futureValue
        updated shouldBe 0
      }
    }

    "adjusting stock" should {
      "successfully adjust stock by positive amount" in {
        val product = Product(
          name = "Adjust Product",
          description = None,
          price = BigDecimal("10.00"),
          stockQuantity = 10
        )
        val created = repository.createProduct(product).futureValue

        val adjusted = repository.adjustStock(created.id.get, 5).futureValue
        adjusted shouldBe 1

        val found = repository.findById(created.id.get).futureValue
        found.get.stockQuantity shouldBe 15
      }

      "successfully adjust stock by negative amount" in {
        val product = Product(
          name = "Adjust Product Negative",
          description = None,
          price = BigDecimal("10.00"),
          stockQuantity = 10
        )
        val created = repository.createProduct(product).futureValue

        val adjusted = repository.adjustStock(created.id.get, -3).futureValue
        adjusted shouldBe 1

        val found = repository.findById(created.id.get).futureValue
        found.get.stockQuantity shouldBe 7
      }

      "not allow negative stock" in {
        val product = Product(
          name = "No Negative Stock",
          description = None,
          price = BigDecimal("10.00"),
          stockQuantity = 5
        )
        val created = repository.createProduct(product).futureValue

        val adjusted = repository.adjustStock(created.id.get, -10).futureValue
        adjusted shouldBe 1

        val found = repository.findById(created.id.get).futureValue
        found.get.stockQuantity shouldBe 0 // Should be 0, not negative
      }

      "return 0 when product doesn't exist" in {
        val adjusted = repository.adjustStock(99999L, 5).futureValue
        adjusted shouldBe 0
      }
    }

    "deleting a product" should {
      "successfully delete the product" in {
        val product = Product(
          name = "Delete Me",
          description = None,
          price = BigDecimal("1.00"),
          stockQuantity = 1
        )
        val created = repository.createProduct(product).futureValue

        val deleted = repository.deleteProduct(created.id.get).futureValue
        deleted shouldBe 1

        val found = repository.findById(created.id.get).futureValue
        found shouldBe None
      }

      "return 0 when product doesn't exist" in {
        val deleted = repository.deleteProduct(99999L).futureValue
        deleted shouldBe 0
      }
    }

    "counting products" should {
      "return total count" in {
        val count = repository.count().futureValue
        count should be > 0
      }
    }

    "checking stock" should {
      "return true when stock is sufficient" in {
        val product = Product(
          name = "Stock Check Product",
          description = None,
          price = BigDecimal("10.00"),
          stockQuantity = 20
        )
        val created = repository.createProduct(product).futureValue

        val available = repository.checkStock(created.id.get, 15).futureValue
        available shouldBe true
      }

      "return false when stock is insufficient" in {
        val product = Product(
          name = "Insufficient Stock Product",
          description = None,
          price = BigDecimal("10.00"),
          stockQuantity = 5
        )
        val created = repository.createProduct(product).futureValue

        val available = repository.checkStock(created.id.get, 10).futureValue
        available shouldBe false
      }

      "return false when product doesn't exist" in {
        val available = repository.checkStock(99999L, 1).futureValue
        available shouldBe false
      }
    }
  }
}
