package com.oms.product.repository

import com.oms.product.model.{Category, Product}
import org.scalatest.BeforeAndAfterAll
import org.scalatest.concurrent.ScalaFutures
import org.scalatest.matchers.should.Matchers
import org.scalatest.time.{Seconds, Span}
import org.scalatest.wordspec.AnyWordSpec
import slick.jdbc.H2Profile.api._
import scala.concurrent.ExecutionContext.Implicits.global

class ProductRepositorySpec extends AnyWordSpec with Matchers with ScalaFutures with BeforeAndAfterAll {

  // Increase timeout for futureValue
  implicit override val patienceConfig = PatienceConfig(timeout = Span(5, Seconds))

  private val db = Database.forURL(
    url = "jdbc:h2:mem:product_test;MODE=PostgreSQL;DB_CLOSE_DELAY=-1;DATABASE_TO_UPPER=false",
    driver = "org.h2.Driver"
  )
  
  private val repository = new ProductRepository(db)

  override def beforeAll(): Unit = {
    super.beforeAll()
    // Create schema
    val setup = DBIO.seq(
      sqlu"""
        CREATE TABLE IF NOT EXISTS categories (
          id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          name VARCHAR(255) NOT NULL,
          description TEXT
        )
      """,
      sqlu"""
        CREATE TABLE IF NOT EXISTS products (
          id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          name VARCHAR(255) NOT NULL,
          description TEXT,
          price DECIMAL(10,2) NOT NULL,
          stock_quantity INT NOT NULL DEFAULT 0,
          category_id BIGINT,
          image_url VARCHAR(500),
          created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
          FOREIGN KEY (category_id) REFERENCES categories(id)
        )
      """
    )
    db.run(setup).futureValue
  }

  override def afterAll(): Unit = {
    db.close()
    super.afterAll()
  }

  "ProductRepository" when {
    "creating a category" should {
      "successfully insert and return category with id" in {
        val category = Category(
          name = "Electronics",
          description = Some("Electronic devices")
        )

        val result = repository.createCategory(category).futureValue

        result.id should not be None
        result.name shouldBe "Electronics"
        result.description shouldBe Some("Electronic devices")
      }
    }

    "finding a category by id" should {
      "return the category when it exists" in {
        val category = Category(name = "Books", description = Some("Book category"))
        val created = repository.createCategory(category).futureValue

        val found = repository.findCategoryById(created.id.get).futureValue

        found should not be None
        found.get.name shouldBe "Books"
        found.get.description shouldBe Some("Book category")
      }

      "return None when category doesn't exist" in {
        val found = repository.findCategoryById(99999L).futureValue
        found shouldBe None
      }
    }

    "finding all categories" should {
      "return all categories" in {
        val categories = repository.findAllCategories().futureValue
        categories.size should be >= 2
      }
    }

    "deleting a category" should {
      "successfully delete the category" in {
        val category = Category(name = "ToDelete", description = None)
        val created = repository.createCategory(category).futureValue

        val deleted = repository.deleteCategory(created.id.get).futureValue
        deleted shouldBe 1

        val found = repository.findCategoryById(created.id.get).futureValue
        found shouldBe None
      }

      "return 0 when category doesn't exist" in {
        val deleted = repository.deleteCategory(99999L).futureValue
        deleted shouldBe 0
      }
    }

    "creating a product" should {
      "successfully insert and return product with id" in {
        val product = Product(
          name = "Test Product",
          description = Some("Test Description"),
          price = BigDecimal("99.99"),
          stockQuantity = 10,
          categoryId = None,
          imageUrl = Some("/uploads/test.jpg")
        )

        val result = repository.createProduct(product).futureValue

        result.id should not be None
        result.name shouldBe "Test Product"
        result.description shouldBe Some("Test Description")
        result.price shouldBe BigDecimal("99.99")
        result.stockQuantity shouldBe 10
        result.imageUrl shouldBe Some("/uploads/test.jpg")
      }

      "successfully insert product with category" in {
        val category = Category(name = "Gadgets", description = None)
        val createdCategory = repository.createCategory(category).futureValue

        val product = Product(
          name = "Gadget Product",
          description = None,
          price = BigDecimal("49.99"),
          stockQuantity = 5,
          categoryId = createdCategory.id,
          imageUrl = None
        )

        val result = repository.createProduct(product).futureValue

        result.id should not be None
        result.categoryId shouldBe createdCategory.id
      }
    }

    "finding a product by id" should {
      "return the product when it exists" in {
        val product = Product(
          name = "Find Me",
          description = Some("Findable product"),
          price = BigDecimal("19.99"),
          stockQuantity = 3
        )
        val created = repository.createProduct(product).futureValue

        val found = repository.findById(created.id.get).futureValue

        found should not be None
        found.get.name shouldBe "Find Me"
        found.get.description shouldBe Some("Findable product")
      }

      "return None when product doesn't exist" in {
        val found = repository.findById(99999L).futureValue
        found shouldBe None
      }
    }

    "finding all products" should {
      "return paginated results" in {
        val products = repository.findAll(0, 10).futureValue
        products should not be empty
      }

      "respect offset and limit" in {
        val firstPage = repository.findAll(0, 2).futureValue
        val secondPage = repository.findAll(2, 2).futureValue

        firstPage should have size 2
        firstPage should not equal secondPage
      }
    }

    "finding products by category" should {
      "return products for specific category" in {
        val category = Category(name = "TestCategory", description = None)
        val createdCategory = repository.createCategory(category).futureValue

        val product1 = Product(
          name = "Product 1",
          description = None,
          price = BigDecimal("10.00"),
          stockQuantity = 1,
          categoryId = createdCategory.id
        )
        val product2 = Product(
          name = "Product 2",
          description = None,
          price = BigDecimal("20.00"),
          stockQuantity = 2,
          categoryId = createdCategory.id
        )

        repository.createProduct(product1).futureValue
        repository.createProduct(product2).futureValue

        val found = repository.findByCategory(createdCategory.id.get, 0, 10).futureValue
        found.size should be >= 2
        found.foreach(_.categoryId shouldBe createdCategory.id)
      }
    }

    "searching products by name" should {
      "return products matching the query" in {
        val product = Product(
          name = "SearchableProduct",
          description = None,
          price = BigDecimal("5.00"),
          stockQuantity = 1
        )
        repository.createProduct(product).futureValue

        val found = repository.searchByName("Searchable", 0, 10).futureValue
        found should not be empty
        found.exists(_.name.contains("Searchable")) shouldBe true
      }

      "be case insensitive" in {
        val product = Product(
          name = "CaseSensitiveProduct",
          description = None,
          price = BigDecimal("5.00"),
          stockQuantity = 1
        )
        repository.createProduct(product).futureValue

        val found = repository.searchByName("casesensitive", 0, 10).futureValue
        found should not be empty
      }
    }

    "updating a product" should {
      "successfully update all fields" in {
        val product = Product(
          name = "Original Name",
          description = Some("Original Description"),
          price = BigDecimal("50.00"),
          stockQuantity = 5
        )
        val created = repository.createProduct(product).futureValue

        val updated = repository.updateProduct(
          id = created.id.get,
          name = Some("Updated Name"),
          description = Some("Updated Description"),
          price = Some(BigDecimal("60.00")),
          stockQuantity = Some(10),
          categoryId = None,
          imageUrl = Some("/uploads/new.jpg")
        ).futureValue

        updated shouldBe 1

        val found = repository.findById(created.id.get).futureValue
        found.get.name shouldBe "Updated Name"
        found.get.description shouldBe Some("Updated Description")
        found.get.price shouldBe BigDecimal("60.00")
        found.get.stockQuantity shouldBe 10
        found.get.imageUrl shouldBe Some("/uploads/new.jpg")
      }

      "successfully update partial fields" in {
        val product = Product(
          name = "Partial Update",
          description = Some("Original"),
          price = BigDecimal("30.00"),
          stockQuantity = 3
        )
        val created = repository.createProduct(product).futureValue

        val updated = repository.updateProduct(
          id = created.id.get,
          name = Some("New Name"),
          description = None,
          price = None,
          stockQuantity = None,
          categoryId = None,
          imageUrl = None
        ).futureValue

        updated shouldBe 1

        val found = repository.findById(created.id.get).futureValue
        found.get.name shouldBe "New Name"
        found.get.description shouldBe Some("Original") // Should keep original
        found.get.price shouldBe BigDecimal("30.00") // Should keep original
      }

      "return 0 when product doesn't exist" in {
        val updated = repository.updateProduct(
          id = 99999L,
          name = Some("New Name"),
          description = None,
          price = None,
          stockQuantity = None,
          categoryId = None,
          imageUrl = None
        ).futureValue

        updated shouldBe 0
      }
    }

    "updating stock" should {
      "successfully update stock quantity" in {
        val product = Product(
          name = "Stock Product",
          description = None,
          price = BigDecimal("10.00"),
          stockQuantity = 5
        )
        val created = repository.createProduct(product).futureValue

        val updated = repository.updateStock(created.id.get, 50).futureValue
        updated shouldBe 1

        val found = repository.findById(created.id.get).futureValue
        found.get.stockQuantity shouldBe 50
      }

      "return 0 when product doesn't exist" in {
        val updated = repository.updateStock(99999L, 50).futureValue
        updated shouldBe 0
      }
    }

    "adjusting stock" should {
      "successfully adjust stock by positive amount" in {
        val product = Product(
          name = "Adjust Product",
          description = None,
          price = BigDecimal("10.00"),
          stockQuantity = 10
        )
        val created = repository.createProduct(product).futureValue

        val adjusted = repository.adjustStock(created.id.get, 5).futureValue
        adjusted shouldBe 1

        val found = repository.findById(created.id.get).futureValue
        found.get.stockQuantity shouldBe 15
      }

      "successfully adjust stock by negative amount" in {
        val product = Product(
          name = "Adjust Product Negative",
          description = None,
          price = BigDecimal("10.00"),
          stockQuantity = 10
        )
        val created = repository.createProduct(product).futureValue

        val adjusted = repository.adjustStock(created.id.get, -3).futureValue
        adjusted shouldBe 1

        val found = repository.findById(created.id.get).futureValue
        found.get.stockQuantity shouldBe 7
      }

      "not allow negative stock" in {
        val product = Product(
          name = "No Negative Stock",
          description = None,
          price = BigDecimal("10.00"),
          stockQuantity = 5
        )
        val created = repository.createProduct(product).futureValue

        val adjusted = repository.adjustStock(created.id.get, -10).futureValue
        adjusted shouldBe 1

        val found = repository.findById(created.id.get).futureValue
        found.get.stockQuantity shouldBe 0 // Should be 0, not negative
      }

      "return 0 when product doesn't exist" in {
        val adjusted = repository.adjustStock(99999L, 5).futureValue
        adjusted shouldBe 0
      }
    }

    "deleting a product" should {
      "successfully delete the product" in {
        val product = Product(
          name = "Delete Me",
          description = None,
          price = BigDecimal("1.00"),
          stockQuantity = 1
        )
        val created = repository.createProduct(product).futureValue

        val deleted = repository.deleteProduct(created.id.get).futureValue
        deleted shouldBe 1

        val found = repository.findById(created.id.get).futureValue
        found shouldBe None
      }

      "return 0 when product doesn't exist" in {
        val deleted = repository.deleteProduct(99999L).futureValue
        deleted shouldBe 0
      }
    }

    "counting products" should {
      "return total count" in {
        val count = repository.count().futureValue
        count should be > 0
      }
    }

    "checking stock" should {
      "return true when stock is sufficient" in {
        val product = Product(
          name = "Stock Check Product",
          description = None,
          price = BigDecimal("10.00"),
          stockQuantity = 20
        )
        val created = repository.createProduct(product).futureValue

        val available = repository.checkStock(created.id.get, 15).futureValue
        available shouldBe true
      }

      "return false when stock is insufficient" in {
        val product = Product(
          name = "Insufficient Stock Product",
          description = None,
          price = BigDecimal("10.00"),
          stockQuantity = 5
        )
        val created = repository.createProduct(product).futureValue

        val available = repository.checkStock(created.id.get, 10).futureValue
        available shouldBe false
      }

      "return false when product doesn't exist" in {
        val available = repository.checkStock(99999L, 1).futureValue
        available shouldBe false
      }

      "return true when stock equals required quantity" in {
        val product = Product(
          name = "Exact Stock Product",
          description = None,
          price = BigDecimal("10.00"),
          stockQuantity = 10
        )
        val created = repository.createProduct(product).futureValue

        val available = repository.checkStock(created.id.get, 10).futureValue
        available shouldBe true
      }
    }

    "finding all products with categories" should {
      "return products with their category names" in {
        val category = Category(name = "WithCategoryTest", description = Some("Test category"))
        val createdCategory = repository.createCategory(category).futureValue

        val product = Product(
          name = "Product With Category",
          description = None,
          price = BigDecimal("15.00"),
          stockQuantity = 5,
          categoryId = createdCategory.id
        )
        repository.createProduct(product).futureValue

        val results = repository.findAllWithCategories(0, 20).futureValue
        results should not be empty
        
        val productWithCategory = results.find(_._1.name == "Product With Category")
        productWithCategory should not be None
        productWithCategory.get._2 shouldBe Some("WithCategoryTest")
      }

      "return products without categories" in {
        val product = Product(
          name = "Product Without Category",
          description = None,
          price = BigDecimal("25.00"),
          stockQuantity = 3,
          categoryId = None
        )
        repository.createProduct(product).futureValue

        val results = repository.findAllWithCategories(0, 20).futureValue
        val productWithoutCategory = results.find(_._1.name == "Product Without Category")
        
        productWithoutCategory should not be None
        productWithoutCategory.get._2 shouldBe None
      }

      "filter by category when categoryFilter is provided" in {
        val category1 = Category(name = "FilterCategory1", description = None)
        val category2 = Category(name = "FilterCategory2", description = None)
        val createdCategory1 = repository.createCategory(category1).futureValue
        val createdCategory2 = repository.createCategory(category2).futureValue

        val product1 = Product(
          name = "Product In Category 1",
          description = None,
          price = BigDecimal("10.00"),
          stockQuantity = 1,
          categoryId = createdCategory1.id
        )
        val product2 = Product(
          name = "Product In Category 2",
          description = None,
          price = BigDecimal("20.00"),
          stockQuantity = 2,
          categoryId = createdCategory2.id
        )

        repository.createProduct(product1).futureValue
        repository.createProduct(product2).futureValue

        val results = repository.findAllWithCategories(0, 20, Some(createdCategory1.id.get)).futureValue
        results.foreach { case (product, categoryName) =>
          product.categoryId shouldBe createdCategory1.id
          categoryName shouldBe Some("FilterCategory1")
        }
      }

      "respect offset and limit" in {
        val firstPage = repository.findAllWithCategories(0, 2).futureValue
        val secondPage = repository.findAllWithCategories(2, 2).futureValue

        firstPage should have size 2
        firstPage should not equal secondPage
      }
    }

    "searching products by name with categories" should {
      "return products matching query with category names" in {
        val category = Category(name = "SearchCategory", description = None)
        val createdCategory = repository.createCategory(category).futureValue

        val product = Product(
          name = "UniqueSearchProduct",
          description = None,
          price = BigDecimal("12.00"),
          stockQuantity = 4,
          categoryId = createdCategory.id
        )
        repository.createProduct(product).futureValue

        val results = repository.searchByNameWithCategories("UniqueSearch", 0, 10).futureValue
        results should not be empty
        
        val foundProduct = results.find(_._1.name == "UniqueSearchProduct")
        foundProduct should not be None
        foundProduct.get._2 shouldBe Some("SearchCategory")
      }

      "be case insensitive" in {
        val product = Product(
          name = "CaseInsensitiveSearchTest",
          description = None,
          price = BigDecimal("8.00"),
          stockQuantity = 2,
          categoryId = None
        )
        repository.createProduct(product).futureValue

        val results = repository.searchByNameWithCategories("caseinsensitive", 0, 10).futureValue
        results should not be empty
        results.exists(_._1.name == "CaseInsensitiveSearchTest") shouldBe true
      }

      "filter by category when categoryFilter is provided" in {
        val category1 = Category(name = "SearchFilterCat1", description = None)
        val category2 = Category(name = "SearchFilterCat2", description = None)
        val createdCategory1 = repository.createCategory(category1).futureValue
        val createdCategory2 = repository.createCategory(category2).futureValue

        val product1 = Product(
          name = "SearchFilter Product One",
          description = None,
          price = BigDecimal("10.00"),
          stockQuantity = 1,
          categoryId = createdCategory1.id
        )
        val product2 = Product(
          name = "SearchFilter Product Two",
          description = None,
          price = BigDecimal("20.00"),
          stockQuantity = 2,
          categoryId = createdCategory2.id
        )

        repository.createProduct(product1).futureValue
        repository.createProduct(product2).futureValue

        val results = repository.searchByNameWithCategories("SearchFilter", 0, 20, Some(createdCategory1.id.get)).futureValue
        results should not be empty
        results.foreach { case (product, categoryName) =>
          product.categoryId shouldBe createdCategory1.id
          categoryName shouldBe Some("SearchFilterCat1")
        }
      }

      "return empty when no products match" in {
        val results = repository.searchByNameWithCategories("NonExistentProductName12345", 0, 10).futureValue
        results shouldBe empty
      }

      "respect offset and limit" in {
        // Create multiple products for pagination
        (1 to 5).foreach { i =>
          val product = Product(
            name = s"PaginationSearchProduct$i",
            description = None,
            price = BigDecimal("5.00"),
            stockQuantity = 1,
            categoryId = None
          )
          repository.createProduct(product).futureValue
        }

        val firstPage = repository.searchByNameWithCategories("PaginationSearch", 0, 2).futureValue
        val secondPage = repository.searchByNameWithCategories("PaginationSearch", 2, 2).futureValue

        firstPage should have size 2
        secondPage should have size 2
        firstPage should not equal secondPage
      }
    }

    "updating product with category" should {
      "successfully update category" in {
        val category1 = Category(name = "OriginalCategory", description = None)
        val category2 = Category(name = "NewCategory", description = None)
        val createdCategory1 = repository.createCategory(category1).futureValue
        val createdCategory2 = repository.createCategory(category2).futureValue

        val product = Product(
          name = "Category Update Product",
          description = None,
          price = BigDecimal("10.00"),
          stockQuantity = 1,
          categoryId = createdCategory1.id
        )
        val created = repository.createProduct(product).futureValue

        val updated = repository.updateProduct(
          id = created.id.get,
          name = None,
          description = None,
          price = None,
          stockQuantity = None,
          categoryId = createdCategory2.id,
          imageUrl = None
        ).futureValue

        updated shouldBe 1

        val found = repository.findById(created.id.get).futureValue
        found.get.categoryId shouldBe createdCategory2.id
      }
    }

    "edge cases" should {
      "handle products with zero price" in {
        val product = Product(
          name = "Zero Price Product",
          description = None,
          price = BigDecimal("0.00"),
          stockQuantity = 1
        )
        val created = repository.createProduct(product).futureValue

        created.price shouldBe BigDecimal("0.00")
      }

      "handle products with very large price" in {
        val product = Product(
          name = "Expensive Product",
          description = None,
          price = BigDecimal("99999999.99"),
          stockQuantity = 1
        )
        val created = repository.createProduct(product).futureValue

        created.price shouldBe BigDecimal("99999999.99")
      }

      "handle products with zero stock" in {
        val product = Product(
          name = "Zero Stock Product",
          description = None,
          price = BigDecimal("10.00"),
          stockQuantity = 0
        )
        val created = repository.createProduct(product).futureValue

        created.stockQuantity shouldBe 0
      }

      "handle empty search query" in {
        val results = repository.searchByName("", 0, 10).futureValue
        // Empty string should match all products (contains empty string)
        results should not be empty
      }

      "handle very long product names" in {
        val longName = "A" * 200
        val product = Product(
          name = longName,
          description = None,
          price = BigDecimal("10.00"),
          stockQuantity = 1
        )
        val created = repository.createProduct(product).futureValue

        created.name shouldBe longName
      }

      "handle very long descriptions" in {
        val longDescription = "Description " * 100
        val product = Product(
          name = "Long Description Product",
          description = Some(longDescription),
          price = BigDecimal("10.00"),
          stockQuantity = 1
        )
        val created = repository.createProduct(product).futureValue

        created.description shouldBe Some(longDescription)
      }
    }
  }
}
